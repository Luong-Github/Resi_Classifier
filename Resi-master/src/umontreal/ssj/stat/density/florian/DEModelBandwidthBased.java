package umontreal.ssj.stat.density.florian;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

import umontreal.ssj.functionfit.LeastSquares;
import umontreal.ssj.hups.BakerTransformedPointSet;
import umontreal.ssj.hups.CachedPointSet;
import umontreal.ssj.hups.FaureSequence;
import umontreal.ssj.hups.IndependentPointsCached;
import umontreal.ssj.hups.LMScrambleShift;
import umontreal.ssj.hups.NestedUniformScrambling;
import umontreal.ssj.hups.PointSet;
import umontreal.ssj.hups.PointSetRandomization;
import umontreal.ssj.hups.RQMCPointSet;
import umontreal.ssj.hups.RandomShift;
import umontreal.ssj.hups.Rank1Lattice;
import umontreal.ssj.hups.SobolSequence;
import umontreal.ssj.hups.StratifiedUnitCube;
import umontreal.ssj.mcqmctools.MonteCarloModelDouble;
import umontreal.ssj.mcqmctools.RQMCExperiment;
import umontreal.ssj.mcqmctools.RQMCExperimentSeries;
import umontreal.ssj.mcqmctools.florian.examples.LookbackOptionGBM;
import umontreal.ssj.probdist.NormalDist;
import umontreal.ssj.rng.MRG32k3a;
import umontreal.ssj.rng.RandomStream;
import umontreal.ssj.stat.PgfDataTable;
import umontreal.ssj.stat.Tally;
import umontreal.ssj.stat.density.DEDerivativeGaussian;
import umontreal.ssj.stat.density.DEHistogram;
import umontreal.ssj.stat.density.DEKernelDensity;
import umontreal.ssj.stat.density.DensityDerivativeEstimator;
import umontreal.ssj.stat.density.DensityEstimator;
import umontreal.ssj.util.Num;
import umontreal.ssj.util.PrintfFormat;

/**
 * @remark **Florian:** Basically, this class provides the tools for density
 *         estimation via KDE and Histogram as we had in our paper, including a
 *         main-function to run experiments. The implementation is unnecessarily
 *         complicated since it somehow grew with the experiments, completely
 *         neglecting design issues. Also, I think the number of plots produced
 *         is too high when we run the experiment with different types of RQMC
 *         point sets. Quite comprehensive documentation is provided, but
 *         probably needs to be polished before publication.
 * 
 *         Implements a parametric model that is particularly designed for the
 *         estimation of the density of a random variable \f$X = g(\mathbf
 *         U)\f$, where \f$\mathbf U = (U_1,U_2,\dots,U_d)\sim U(0,1)^d \f$ with
 *         a given function \f$g:(0,1)^d\rightarrow\mathbb{R}\f$ over a finite
 *         interval \f$[a,b]\f$. Such situations arise naturally in uncertainty
 *         quantification. The observations \f$X_0,X_1,\dots,X_{n-1}\f$ which
 *         are used to construct the density will typically be generated by
 *         simulation of \f$\mathbf U\f$, either by Monte Carlo (MC) or by
 *         randomized quasi-Monte Carlo (RQMC).
 * 
 *         The model applies to density estimators that rely on the selection of
 *         a bandwidth (or binwidth) and is currently implemented for histogram
 *         estimators, see @ref DEHistogram, and kernel density estimators
 *         (KDEs), see \ref DEKernelDensity. An extension to other
 *         bin-/bandwidth based estimators is easy to obtain as is explained
 *         further below. The model is thoroughly investigated in (TODO: cite
 *         our paper) and can be explained as follows. It is known in general,
 *         that the mean integrated square error (MISE) can be rewritten as the
 *         sum of the integrated variance (IV) and the integrated square bias
 * 
 *         @f[ \textrm{MISE} = \int_a^b\mathbb{E} [\hat{f}_{n,h}(x) -
 *         f(x)]^2\mathrm{d}x =
 *         \int_a^b\textrm{Var}[\hat{f}_{n,h}(x)]\mathrm{d}x + \int_a^b \left(
 *         \mathbb{E}[\hat{f}_{n,h}(x)] - f(x) \right)^2\mathrm{d}x =
 *         \textrm{IV} + \textrm{ISB}, @f]
 * 
 *         where \f$f\f$ denotes the true density and \f$\hat{f}_{n,h}\f$ the
 *         density estimator. For MC it is known that, asymptotically,
 *         \f$\textrm{IV}\approx C n^{-1} h^{-1}\f$ and \f$\textrm{ISB}\approx B
 *         h^{\alpha}\f$, \f$C,B,\alpha>0\f$. Observe that the power of \f$h\f$
 *         is positive in the ISB, while it appears to be negative in the IV.
 * 
 *         The goal is to select an optimal band- or binwidth \f$h_*\f$ which
 *         balances these two terms. This is also known as the infamous
 *         <em>variance-bias tradeoff</em>. One can do so, as soon as all the
 *         parameters \f$C,B,\alpha\f$ are explicitly known or can be
 *         sufficiently well estimated, at least. For histograms and KDEs this
 *         is indeed the case. Let \f$R(g)\f$ denote the roughness functional
 *         over the interval \f$[a,b]\f$ and let \f$\mu_k(g)\f$ be the
 *         \f$k\f$-th moment of a function \f$g\f$, i.e.
 * 
 *         \f[ R(g) = \int_a^bg^2(x)\mathrm{d}x,\qquad\text{and}\quad
 *         \mu_k(g)=\int_{-\infty}^{\infty}x^kg(x)\mathrm{d}x. \f]
 * 
 *         Assuming that all the entities exist and are finite, the table below
 *         lists the parameter values for histograms and KDEs for observations
 *         generated with MC, see \cite tSCO15a.
 * 
 *         <center>
 *         <table>
 *         <caption id="mc_parameters"> Asymptotically optimal parameter values
 *         with MC</caption>
 *         <tr>
 *         <th>Parameter
 *         <th>Histogram
 *         <th>KDE
 *         <tr>
 *         <td>@f$C@f$
 *         <td>1
 *         <td>@f$\mu_0(K^2)@f$
 *         <tr>
 *         <td>@f$\alpha@f$
 *         <td>2
 *         <td>4
 *         <tr>
 *         <td>@f$B@f$
 *         <td>@f$R(f')/12@f$
 *         <td>@f$ \mu_2^2(K) R(f'')/4@f$
 *         </table>
 *         </center>
 * 
 *         The only highly unpleasant quantities are the roughness functional of
 *         the first or second derivative of the unknown density. This, however,
 *         can be overcome by using derivative estimates as implemented in \ref
 *         DensityDerivativeEstimator and plugging the results back into the
 *         expression for the ISB. Here, the kernel selected for the derivative
 *         estimation is a standard normal. To estimate the
 *         \f$h^{r_0}_{\text{AMISE}} \f$, where \f$r_0\in\{1,2\}\f$, as can be
 *         seen in the table above, we use one step of the recursion
 *         DensityDerivativeEstimator#hAmiseR(int, int, double, double[],
 *         double, DensityDerivativeEstimator, double[], double[], double,
 *         double). For the initial value we estimate the empirical standard
 *         deviation \f$\hat{\sigma}\f$ from the observations
 *         \f$X_0,\dots,X_{n-1}\f$ and assume \f$f\f$ to be a normal
 *         distribution with standard deviation \f$\hat{\sigma}\f$.
 * 
 *         If the user wishes to use different kernels or other initial values
 *         than those stated above, it is only necessary to override the
 *         corresponding methods for estimating \f$B\f$. The rest will remain
 *         intact.
 * 
 *         Let us now turn to the IV. What changes with RQMC is that it can
 *         cause significant variance reduction, which, however, can come at the
 *         price of a worse dependency on \f$h\f$. This was proven theoretically
 *         and also observed empirically in (TODO: cite our paper). To reflect
 *         this behavior, we choose the model
 * 
 *         \f[ \textrm{IV}\approx C n^{-\beta}h^{-\delta},\qquad \beta,\delta>1,
 *         \f]
 * 
 *         locally, i.e. within a small region w.r.t. \f$(n,h)\f$. This proved
 *         to be a reasonable assumption.
 * 
 *         Observe that taking the logarithm of both sides of the above model
 *         assumption yields a linear model with variables \f$\log n\f$ and
 *         \f$\log h\f$, and unknown parameters \f$\log C,\beta,\delta\f$. Based
 *         on this linear model, one can estimate the empirical IV for several
 *         reasonable values of \f$(n,h)\f$ with the methods provided by \ref
 *         DensityEstimator and subsequently obtain estimates for the unknown
 *         parameters. Together with the estimated parameters from the ISB, one
 *         can thus compute an estimate for \f$h_*\f$
 * 
 *         \f[ h_* = \kappa n^{-\gamma},\qquad\text{with }\kappa = \left(\frac{C
 *         \delta}{B \alpha} \right)^{1/(\alpha + \delta)},~\gamma =
 *         \frac{\beta}{\alpha+\delta}, \f]
 * 
 *         as well as the modeled MISE
 * 
 *         \f[ \textrm{MISE} \approx Kn^{-\nu} ,\qquad\text{with } K = C
 *         \kappa^{-\delta} + B
 *         \kappa^{\alpha},~\nu=\frac{\alpha\beta}{\alpha+\delta}. \f]
 * 
 *         The main method of this class is #testMISERate which, in turn, is
 *         made up of three main components. These are #parametersIVestimate,
 *         #parametersISBEstimate, and #estimateMISEOptH. The first component
 *         uses a test grid w.r.t. \f$(n,h)\f$ at which it estimates the
 *         empirical IV and, subsequently, estimates the IV-parameters by linear
 *         regression. The second component carries out the task of computing
 *         the parameter \f$ B\f$ as described above. The method
 *         #estimateMISEOptH computes the optimal bin-/bandwidth \f$h_*\f$ and
 *         runs the experiment for the optimal bin-/bandwidth with newly
 *         generated observations. It needs to be added that two flags can be
 *         set, which are set to <tt>false</tt> by default. If <tt>true</tt>,
 *         #displayExec prints output during the runtime of the program and
 *         #producePlots generates plots at the end of the program. The output
 *         of all the variants of the main method is a formatted string
 *         containing a detailed report of the entire experiment.
 * 
 *         Finally, if the user wants to use this class for other estimators
 *         than @ref DEHistogram or @ref DEKernelDensity this can easily be
 *         achieved by implementing the methods #setH(DensityEstimator, double)
 *         and #setAlpha(DensityEstimator) specifically for this estimator.
 */

public class DEModelBandwidthBased {

	/** Power of \f$h\f$ in ISB */
	private double alpha;
	/** Multiplicative constant in ISB */
	private double B;
	/** Negative power of \f$n\f$ in IV */
	private double beta;
	/** Multiplicative constant in IV */
	private double C;
	/** Negative power of \f$h\f$ in IV */
	private double delta;

	/**
	 * left boundary of the interval over which we estimate.
	 */
	private double a;
	/**
	 * right boundary of the interval over which we estimate.
	 */
	private double b;
	/**
	 * flag whether to display output during running experiment or not.
	 */
	protected boolean displayExec = false;

	/**
	 * flag, whether to produce plots at the end of the experiment or not.
	 */
	protected boolean producePlots = false;

	/**
	 * base of all logarithms used in the experiment. Defaults to 2.
	 */
	protected double baseOfLog = 2.0;

	private double logOfBase = Math.log(2.0);

	/**
	 * logarithms in base #baseOfLog of the number of points.
	 */
	protected double[] logN;

	/**
	 * logarithms in base #baseOfLog of the bin-/bandwidths.
	 */
	protected double[] logH;

	/**
	 * logarithms of the optimal bandwidth h_* for each value in #logN.
	 */
	protected double[] logHOpt;

	/**
	 * The loglogarithm of the estimated empirical IV of the estimator for the pairs
	 * (n,h) in the testing region #logN \f$\times\f$ #logH.
	 */
	protected double[] logIV3D;

	/**
	 * The logarithm of the estimated empirical IV of the estimator for each element
	 * in #logN with the corresponding optimal \f$h\f$, #logHOpt.
	 */
	protected double[] logIV;
	/**
	 * The logarithm of the estimated empirical MISE of the estimator for each
	 * element in #logN with the corresponding optimal \f$h\f$, #logHOpt. More
	 * precisely, the sum of the estimated empirical IV and the modeled ISB.
	 */
	protected double[] logMISE;

	/**
	 * The logartihm of the modelled IV for each value in #logN with the
	 * corresponding optimal \f$h\f$, #logHOpt.
	 */
	protected double[] logEstIV;
	/**
	 * The logartihm of the modelled ISB for each value in #logN with the
	 * corresponding optimal \f$h\f$, #logHOpt.
	 */
	protected double[] logEstISB;
	/**
	 * The logartihm of the modelled MISE for each value in #logN with the
	 * corresponding optimal \f$h\f$, #logHOpt.
	 */
	protected double[] logEstMISE;

	/**
	 * Axis labels for the 3D plots.
	 */
	private String[] tableFields3D = { "log(n)", "log(h)", "log(IV)", "estimated-log(IV)" };
	/**
	 * Axis labels for the 2D plots.
	 */
	private String[] tableFields = { "log(n)", "log(IV)", "log(MISE)", "estimated-log(IV)", "estimated-log(ISB)",
			"estimated-log(MISE)" };

	/**
	 * Constructs an instance of this parametric model over the interval
	 * \f$[a,b]\f$. The density estimator \a de is only used to determine the value
	 * for \f$\alpha\f$ and does currently only work with \ref DEHistogram and \ref
	 * DEKernelDensity. In any other case refer to #DEModelBandwidthBased(double,
	 * MonteCarloModelDouble, double, double). Or implement #setAlpha for the
	 * desired estimator.
	 * 
	 * @param de the density estimator to obtain \f$\alpha\f$.
	 * @param a  left boundary of the interval over which we estimate.
	 * @param b  right boundary of the interval over which we estimate.
	 */
	public DEModelBandwidthBased(DensityEstimator de, double a, double b) {

		setRange(a, b);
		setAlpha(de);
	}

	public DEModelBandwidthBased(DEHistogram de, double a, double b) {

		setRange(a, b);
		setAlpha(de);
	}

	public DEModelBandwidthBased(DEKernelDensity de, double a, double b) {

		setRange(a, b);
		setAlpha(de);
	}

	/**
	 * Constructs an instance of this parametric model over the interval
	 * \f$[a,b]\f$.
	 * 
	 * @param alpha the value for \f$\alpha\f$ used.
	 * @param a     left boundary of the interval over which we estimate.
	 * @param b     right boundary of the interval over which we estimate.
	 */
	public DEModelBandwidthBased(double alpha, double a, double b) {
		this.alpha = alpha;
		setRange(a, b);
	}

	/**
	 * Sets #displayExec, i.e. the flag whether to display output during the runtime
	 * of the experiment or not to \a displayExec.
	 * 
	 * @param displayExec flag, whether display output during runtime or not.
	 */
	public void setDisplayExec(boolean displayExec) {
		this.displayExec = displayExec;
	}

	/**
	 * Gives #displayExec, i.e. the flag whether to display output during the
	 * runtime of the experiment or not.
	 * 
	 * @return flag, whether to display output during runtime or not.
	 */
	public boolean getDisplayExec() {
		return displayExec;
	}

	/**
	 * Sets #producePlots, i.e. the flag whether to produce plots at the end of the
	 * experiment or not to \a producePlots.
	 * 
	 * @param producePlots flag, whether to produce plots at the end of the
	 *                     experiment or not.
	 */
	public void setProducePlots(boolean producePlots) {
		this.producePlots = producePlots;
	}

	/**
	 * Gives #producePlots, i.e. the flag whether to produce plots at the end of the
	 * experiment or not.
	 * 
	 * @return flag, whether to produce plots at the end of experiment or not.
	 */
	public boolean getProducePlots() {
		return producePlots;
	}

	/**
	 * Sets the current interval over which we estimate to \f$[a,b]\f$.
	 * 
	 * @param a left boundary of the interval over which we estimate.
	 * @param b right boundary of the interval over which we estimate.
	 */
	public void setRange(double a, double b) {
		this.a = a;
		this.b = b;
	}

	/**
	 * Gives the left boundary of the interval over which we estimate.
	 * 
	 * @return the left boundary of the interval over which we estimate.
	 */
	public double geta() {
		return a;
	}

	/**
	 * Gives the right boundary of the interval over which we estimate.
	 * 
	 * @return the right boundary of the interval over which we estimate.
	 */
	public double getb() {
		return b;
	}

	/**
	 * Sets the base for all logarithms in the experiment to \a base.
	 * 
	 * @param base the base for all logarithms.
	 */
	public void setBaseOfLog(double base) {
		this.baseOfLog = base;
		logOfBase = Math.log(base);
	}

	/**
	 * Gives the base of the logarithms in this experiment, #baseOfLog.
	 * 
	 * @return the base of the logarithms in this experiment.
	 */
	public double getBaseOfLog() {
		return baseOfLog;
	}

	/**
	 * Gives the current value of \f$alpha\f$.
	 * 
	 * @return the current value of \f$\alpha\f$.
	 */
	public double getAlpha() {
		return alpha;
	}

	/**
	 * Sets the current value of \f$\alpha\f$ to \a alpha.
	 * 
	 * @param alpha the desired value for \f$\alpha\f$.
	 */
	public void setAlpha(double alpha) {
		this.alpha = alpha;
	}

	/**
	 * Sets the current value of \f$\alpha\f$ to 2.
	 * 
	 * @param de
	 */
	public void setAlpha(DEHistogram de) {
		setAlpha(2.0);
	}

	/**
	 * Sets the current value of \f$\alpha\f$ to 4.
	 * 
	 * @param de
	 */
	public void setAlpha(DEKernelDensity de) {
		setAlpha(4.0);
	}

	/**
	 * If \a de is neither a histogram or a KDE, nor has a separate method for the
	 * type of \a de has been implemented, this method will throw an exception.
	 * 
	 * @param de
	 */
	public void setAlpha(DensityEstimator de) {
		throw new UnsupportedOperationException("setAlpha is not implemented for DesityEstimator " + de.toString()
				+ ". Either implement this" + " method or use setAlpha(double)");
	}

	/**
	 * Gives the current value of \f$B\f$.
	 * 
	 * @return the current value of \f$B\f$.
	 */
	public double getB() {
		return B;
	}

	/**
	 * Sets the current value of \f$B\f$ to \a B.
	 * 
	 * @param B the desired value for \f$B\f$.
	 */
	public void setB(double B) {
		this.B = B;
	}

	/**
	 * Sets the current value of \f$\beta\f$ to \a beta.
	 * 
	 * @param beta the desired value for \f$\beta\f$.
	 */
	public void setBeta(double beta) {
		this.beta = beta;
	}

	/**
	 * Gives the current value of \f$\beta\f$.
	 * 
	 * @return the current value of \f$\beta\f$.
	 */
	public double getBeta() {
		return beta;
	}

	/**
	 * Sets the current value of \f$C\f$ to \a C.
	 * 
	 * @param C the desired value for \f$C\f$.
	 */
	public void setC(double C) {
		this.C = C;
	}

	/**
	 * Gives the current value of \f$C\f$.
	 * 
	 * @return the current value of \f$C\f$.
	 */
	public double getC() {
		return C;
	}

	/**
	 * Gives the current value of \f$\delta\f$.
	 * 
	 * @return the current value of \f$\delta\f$.
	 */
	public double getDelta() {
		return delta;
	}

	/**
	 * Sets the current value of \f$\delta\f$ to \a delta.
	 * 
	 * @param delta the desired value for \f$\delta\f$.
	 */
	public void setDelta(double delta) {
		this.delta = delta;
	}

	/**
	 * Takes the values \f$\log_b(h)=\f$\a logH and \f$\log_b(n)=\f$\a logN, where
	 * \f$b=\f$#logOfBase, and gives the logarithm in base \f$b\f$ of the modeled
	 * IV, i.e. \f$\log_b(C h^{-\delta} n^{-\beta}) \f$.
	 * 
	 * @param logH the logarithm in base #logOfBase of \f$h\f$.
	 * @param logN the logarithm in base #logOfBase of \f$n\f$.
	 * @return the logarithm modeled IV in base #logOfBase.
	 */
	public double estimateLogIV(double logH, double logN) {
		return (Math.log(getC()) / logOfBase - getBeta() * logN - getDelta() * logH);
	}

	/**
	 * Takes the value \f$\log_b(h)=\f$\a logH, where \f$b=\f$#logOfBase, and gives
	 * the logarithm in base \f$b\f$ of the modeled ISB, i.e. \f$\log_b(B
	 * h^{\alpha}\f$.
	 * 
	 * @param logH the logarithm in base #logOfBase of \f$h\f$.
	 * @return the logarithm modeled ISB in base #logOfBase.
	 */
	public double estimateLogISB(double logH) {
		return (Math.log(getB()) / logOfBase + getAlpha() * logH);
	}

	/**
	 * Takes the value \f$\log_b(n)=\f$\a logN, where \f$b=\f$#logOfBase, and gives
	 * the logarithm in base \f$b\f$ of the modeled MISE, i.e. \f$\log_b(K
	 * n^{-\nu}\f$.
	 * 
	 * @param logN the logarithm in base #logOfBase of \f$n\f$.
	 * @return the logarithm modeled MISE in base #logOfBase.
	 */
	public double estimateLogMISE(double logN) {
		return (Math.log(getK()) / logOfBase - getNu() * logN);
	}

	/**
	 * Sets the bin width of the histogram estimator \a de to \a h.
	 * 
	 * @param de the histogram considered.
	 * @param h  the desired bin width.
	 */
	public static void setH(DEHistogram de, double h) {
		de.setH(h);
	}

	/**
	 * Sets the bin width of the kernel density estimator \a de to \a h.
	 * 
	 * @param de the kernel density estimator considered.
	 * @param h  the desired bin width.
	 */
	public static void setH(DEKernelDensity de, double h) {
		de.setH(h);
	}

	/**
	 * Fallback method for all density estimators \a de for which this method is not
	 * specifically implemented. Throws an \ref UnsupportedOperationException.
	 * 
	 * @param de the density estimator considered.
	 * @param h  the desired bin width.
	 */
	public static void setH(DensityEstimator de, double h) {
		throw new UnsupportedOperationException("setH is not implemented for the DensityEstimator " + de.toString());
	}

	/**
	 * Gives #logH, the logs in base #baseOfLog of the bin-/bandwidths in the test
	 * grid for \f$(n,h)\f$.
	 * 
	 * @return the logs of the bin-/bandwidths considered.
	 */
	public double[] getLogH() {
		return logH;
	}

	/**
	 * Computes the value of \f$\nu=\frac{\alpha\beta}{\alpha+\delta}\f$ in the
	 * modeled MISE.
	 * 
	 * @return the current value of \f$\nu\f$.
	 */
	public double getNu() {
		return getAlpha() * getGamma();
	}

	/**
	 * Computes the value of the parameter \f$ \kappa = \left(\frac{C \delta}{B
	 * \alpha} \right)^{1/(\alpha + \delta)}\f$.
	 * 
	 * @return the current value of \f$\kappa\f$.
	 */
	public double getKappa() {
		return Math.pow(getC() * getDelta() / (getB() * getAlpha()), 1.0 / (getAlpha() + getDelta()));
	}

	/**
	 * Computes the value of the parameter \f$ \gamma =
	 * \frac{\beta}{\alpha+\delta}\f$.
	 * 
	 * @return the current value of \f$\gamma\f$.
	 */
	public double getGamma() {
		return getBeta() / (getAlpha() + getDelta());
	}

	/**
	 * Computes the value of the parameter \f$ K = C \kappa^{-\delta} + B
	 * \kappa^{\alpha},~\nu=\frac{\alpha\beta}{\alpha+\delta}\f$.
	 * 
	 * @return the current value of \f$K\f$.
	 */
	public double getK() {
		double kappa = getKappa();
		return getC() * Math.pow(kappa, -getDelta()) + getB() * Math.pow(kappa, getAlpha());
	}

	/**
	 * Gives #logN, the logarithms in base #baseOfLog of the numbers of observations
	 * considered.
	 * 
	 * @return the logarithms of the numbers of observations considered
	 */
	public double[] getLogN() {
		return logN;
	}

	/**
	 * Sets #logH, the logarithms in base #baseOfLog of the bin-/bandwidths used in
	 * the test grid w.r.t. \f$(n,h)\f$, to \a hArray.
	 * 
	 * @param hArray an array containing the desired bin-/bandwidths for the test
	 *               grid.
	 */
	public void setLogH(double[] hArray) {
		logH = new double[hArray.length];
		for (int i = 0; i < hArray.length; i++)
			logH[i] = Math.log(hArray[i]) / logOfBase;
	}

	/**
	 * Sets #logN, the logarithms in base #baseOfLog of the numbers of observations,
	 * to \a nArray.
	 * 
	 * @param N
	 */
	public void setLogN(int[] nArray) {
		logN = new double[nArray.length];
		for (int i = 0; i < nArray.length; i++)
			logN[i] = Math.log(nArray[i]) / logOfBase;
	}

	/**
	 * For parameter estimation of the IV this method produces and returns a
	 * formatted string containing a head with basic information that can be used as
	 * a introductory head for the estimation of the IV parameters.
	 *
	 * @param pointLabel     a description of the point set employed.
	 * @param estimatorLabel a description of the density estimator.
	 * @param numEvalPoints  the number of evaluation points to estimate the
	 *                       empirical IV
	 * @param m              the number of independent replications of the
	 *                       observations.
	 * @return a formatted introductory head for the parameter estimation of the IV.
	 */
	public String parametersIVFormatHead(String pointLabel, String estimatorLabel, String numEvalPoints, int m) {
		StringBuffer sb = new StringBuffer("");
		sb.append("Model parameter estimation for the IV over the interval [" + a + ", " + b + "]\n");
		sb.append("----------------------------------------------------------------\n\n");
		sb.append("Estimator: " + estimatorLabel + "\n");
		sb.append("Point set used: " + pointLabel + "\n");
		sb.append("Number of repititions: m = " + m + "\n");
		sb.append("Evaluation points: " + numEvalPoints + "\n");
		sb.append("----------------------------------------------------------------\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	/**
	 * Same as #parametersIVFormatHead(String, String, String, int) but replaces the
	 * field for the number of evaluation points by "variable". This can be used
	 * when passing evaluation points is not necessary for IV estimation, as is the
	 * case for histograms, for instance.
	 * 
	 * @param pointLabel     a description of the point set employed.
	 * @param estimatorLabel a description of the density estimator.
	 * @param m              the number of independent replications of the
	 *                       observations.
	 * @return a formatted introductory head for the parameter estimation of the IV.
	 */
	public String parametersIVFormatHead(String pointLabel, String estimatorLabel, int m) {
		return parametersIVFormatHead(pointLabel, estimatorLabel, "variable", m);
	}

	/**
	 * Routine to initialize #logN, #logH, and #logIV3D for the estimation of the IV
	 * parameters. The array \a rqmcPts is only used to determine the numbers of
	 * observations.
	 * 
	 * @param rqmcPts the RQMC point set of different sizes.
	 * @param hArray  the bin-/bandwidths from the testing grid for \f$(n,h)\f$.
	 */
	public void parametersIVPreprocess(RQMCPointSet[] rqmcPts, double[] hArray) {
		logIV3D = new double[rqmcPts.length * hArray.length];
		setLogH(hArray);
		logN = new double[rqmcPts.length];
		for (int i = 0; i < rqmcPts.length; i++)
			logN[i] = Math.log((double) rqmcPts[i].getNumPoints()) / logOfBase;
	}

	/**
	 * Computes the data for the IV over a testing grid for \f$(n,h)\f$ and returns
	 * a formatted table as a string. More precisely, for each RQMC point set in \a
	 * rqmcPts it produces \a m independent replications of the underlying model
	 * \model. Subsequently, the density estimator \a de is evaluated at \a
	 * evalPoints for each \f$h\f$. On the basis of these evaluation the IV is
	 * estimated. The pairs \f$(n,h)\f$ are stored in \a regDataX, where \f$n\f$
	 * denotes the size of the corresponding point set, and the IV estimates are
	 * written into #logIV3D.
	 * 
	 * @param model      the underlying model.
	 * @param rqmcPts    RQMC point sets of different sizes.
	 * @param m          the number of independent replications of the model for
	 *                   each RQMC point set.
	 * @param de         the density estimator considered.
	 * @param hArray     the desired values for \f$h\f$ for the testing grid.
	 * @param regDataX   two-dimensional array to which the testing grid is stored.
	 * @param evalPoints the evaluation points used for estimating the empirical IV.
	 * @return a formatted table summarizing the experiment.
	 */
	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m,
			DensityEstimator de, double[] hArray, double[][] regDataX, double[] evalPoints) {
		double[] variance;
		double[][] data;
		double[][] density;
		Tally statReps = new Tally();
		String str;
		StringBuffer sb = new StringBuffer("");

		str = "log(n)\t\t log(h)\t\t empirical IV \n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		for (int i = 0; i < logN.length; i++) { // point sets indexed by i
			for (int j = 0; j < logH.length; j++) { // h's indexed by j
				data = new double[m][];

				RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
				setH(de, hArray[j]);
				density = new double[m][evalPoints.length];
				density = de.evalDensity(evalPoints, data);

				variance = new double[evalPoints.length];

				regDataX[i * logH.length + j] = new double[2];
				regDataX[i * logH.length + j][0] = logN[i];
				regDataX[i * logH.length + j][1] = logH[j];

				logIV3D[i * logH.length + j] = Math.log(DensityEstimator.computeIV(density, a, b, variance))
						/ logOfBase;

				str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(6, 4, logH[j]) + "\t "
						+ logIV3D[i * logH.length + j] + "\n";
				sb.append(str);
				if (displayExec)
					System.out.print(str);
			}

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();
	}

	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m,
			DEKernelDensity de, double[] hArray, double[][] regDataX, double[] evalPoints) {
		double[] variance;
		double[][] data;
		double[][] density;
		Tally statReps = new Tally();
		String str;
		StringBuffer sb = new StringBuffer("");

		str = "log(n)\t\t log(h)\t\t empirical IV \n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		for (int i = 0; i < logN.length; i++) { // point sets indexed by i
			for (int j = 0; j < logH.length; j++) { // h's indexed by j
				data = new double[m][];

				RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
				setH(de, hArray[j]);
				density = new double[m][evalPoints.length];
				density = de.evalDensity(evalPoints, data);

				variance = new double[evalPoints.length];

				regDataX[i * logH.length + j] = new double[2];
				regDataX[i * logH.length + j][0] = logN[i];
				regDataX[i * logH.length + j][1] = logH[j];

				logIV3D[i * logH.length + j] = Math.log(DensityEstimator.computeIV(density, a, b, variance))
						/ logOfBase;

				str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(6, 4, logH[j]) + "\t "
						+ logIV3D[i * logH.length + j] + "\n";
				sb.append(str);
				if (displayExec)
					System.out.print(str);
			}

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();
	}

	/**
	 * Similar to #parametersIVComputeRegData(MonteCarloModelDouble, RQMCPointSet[],
	 * int, DensityEstimator, double[], double[][], double[]), but specifically for
	 * histograms. Recall that passing evaluation points is not necessary for a \ref
	 * DEHistogram, as the IV is constant on each bin.
	 * 
	 * @param model    the underlying model.
	 * @param rqmcPts  RQMC point sets of different sizes.
	 * @param m        the number of independent replications of the model for each
	 *                 RQMC point set.
	 * @param de       the density estimator considered.
	 * @param hArray   the desired values for \f$h\f$ for the testing grid.
	 * @param regDataX two-dimensional array to which the testing grid is stored.
	 * @return a formatted table summarizing the experiment.
	 */
	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] hArray, double[][] regDataX) {
		double[] variance;
		double[][] data;
		double[][] density;
		int numBins;
		Tally statReps = new Tally();
		String str;
		StringBuffer sb = new StringBuffer("");

		str = "log(n)\t\t log(h)\t\t log of empirical IV \n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		for (int i = 0; i < logN.length; i++) { // point sets indexed by i
			for (int j = 0; j < logH.length; j++) { // h's indexed by j
				data = new double[m][];

				RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
				// de.setData(data[0]);
				// setH(de,hArray[j]);
				numBins = (int) ((b - a) / hArray[j]);

				density = new double[m][numBins];
				density = DEHistogram.evalDensity(data, a, b, numBins);

				variance = new double[numBins];

				regDataX[i * logH.length + j] = new double[2];
				regDataX[i * logH.length + j][0] = logN[i];
				regDataX[i * logH.length + j][1] = logH[j];

				logIV3D[i * logH.length + j] = Math.log(DensityEstimator.computeIV(density, a, b, variance))
						/ logOfBase;

				str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(6, 4, logH[j]) + "\t "
						+ logIV3D[i * logH.length + j] + "\n";
				sb.append(str);
				if (displayExec)
					System.out.print(str);
			}

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();
	}

	/**
	 * Same as #parametersIVComputeRegData(MonteCarloModelDouble, RQMCPointSet[],
	 * int, DEHistogram, double[], double[][]), but contains one placeholder
	 * parameter to match the structure of
	 * parametersIVComputeRegData(MonteCarloModelDouble, RQMCPointSet[], int,
	 * DensityEstimator, double[], double[][], double[])
	 * 
	 * @param model      the underlying model.
	 * @param rqmcPts    RQMC point sets of different sizes.
	 * @param m          the number of independent replications of the model for
	 *                   each RQMC point set.
	 * @param de         the density estimator considered.
	 * @param hArray     the desired values for \f$h\f$ for the testing grid.
	 * @param regDataX   two-dimensional array to which the testing grid is stored.
	 * @param evalPoints placeholder.
	 * @return a formatted table summarizing the experiment.
	 */
	public String parametersIVComputeRegData(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] hArray, double[][] regDataX, double[] evalPoints) {
		return parametersIVComputeRegData(model, rqmcPts, m, de, hArray, regDataX);
	}

	/**
	 * Takes the testing grid for \f$(n,h)\f$ in \a regDataX and performs a linear
	 * regression with the data saved in #logIV3D. Subsequently, it sets the
	 * parameters \f$C\f$, \f$\beta\f$, and \f$delta\f$ to the values obtained.
	 * 
	 * @param regDataX the testing grid \f$(n,h)\f$.
	 */
	public void parametersIVComputeCoefficients(double[][] regDataX) {
		double[] regCoeffs = LeastSquares.calcCoefficients0(regDataX, logIV3D);
		setC(Math.pow(baseOfLog, regCoeffs[0]));
		setBeta(-regCoeffs[1]);
		setDelta(-regCoeffs[2]);
	}

	/**
	 * Gives the current values of the parameters \f$C\f$, \f$\beta\f$, and
	 * \f$delta\f$ as formatted string.
	 * 
	 * @return the IV parameters in a formatted string.
	 */
	public String parametersIVFormatCoefficients() {

		String str = "Estimated IV-parameters:\n";
		str += "-------------------------------------\n";
		str += "C =\t" + getC() + "\n";
		str += "beta =\t" + getBeta() + "\n";
		str += "delta =\t" + getDelta() + "\n\n";

		double[] estData = new double[logIV3D.length];
		for (int i = 0; i < logN.length; i++) {
			for (int j = 0; j < logH.length; j++) {
				estData[i * logH.length + j] = Math.log(getC()) / logOfBase - getBeta() * logN[i]
						- getDelta() * logH[j];
			}
		}

		double r2 = coefficientOfDetermination(logIV3D, estData);

		str += "R^2 =\t" + r2 + "\n\n";
		if (displayExec)
			System.out.print(str);

		return str;
	}

	/**
	 * Same as #parametersIVEstimate(MonteCarloModelDouble, RQMCPointSet[], int,
	 * DEHistogram, double[]), but without passing evaluation points. Recall that
	 * the IV is constant on each bin of the histogram, so considering one
	 * evaluation point per bin only is usually more efficient.
	 * 
	 * 
	 * @param rqmcPts the RQMC point sets to construct the observation.
	 * @param model   the underlying model, from which the observations are
	 *                obtained.
	 * @param m       the number of independent repetitions.
	 * @param de      the histogram.
	 * @param hArray  the values for \f$h\f$ of the testing region.
	 * @return a formatted String containing all the information about this
	 *         parameter estimation.
	 */
	public String parametersIVEstimate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] hArray) {
		StringBuffer sb = new StringBuffer("");

		parametersIVPreprocess(rqmcPts, hArray);

		double[][] regDataX = new double[logIV3D.length][];

		sb.append(parametersIVFormatHead(rqmcPts[0].getLabel(), de.toString(), m));

		sb.append(parametersIVComputeRegData(model, rqmcPts, m, de, hArray, regDataX));

		parametersIVComputeCoefficients(regDataX);

		sb.append(parametersIVFormatCoefficients());

		return sb.toString();
	}

	/**
	 * This method is the core function for estimating the IV parameters \f$C\f$,
	 * \f$\beta\f$, and \f$delta\f$ by estimating the empirical IV over a testing
	 * region for \f$(n,h)\f$ and, subsequently, performing a linear regression.
	 * 
	 * More precisely, \a rqmcPts is intended to contain the same type of point set
	 * in different sizes \f$n\f$. These sizes are the \f$n\f$-values for the
	 * testing region. The \f$h\f$-values are passed in \a hArray. For every point
	 * in \a rqmcPts it generates observations of \a model. This is repeated \f$m\f$
	 * times independently. On the basis of these observations it estimates the
	 * empirical IV for every \f$h\f$ in \a hArray. The evaluation points used to
	 * estimate the empirical IV are passed in \a evalPoints The estimated IVs are
	 * stored in #logIV3D. Finally, this data is used to estimate the parameters by
	 * a linear regression.
	 * 
	 * 
	 * The string which is returned is composed of an introductory heading, a table
	 * showing the results of the estimates of the empirical IV for different
	 * \f$n\f$ and \f$h\f$, and a formatted output of the estimated parameters
	 * \f$C\f$, \f$\beta\f$, and \f$delta\f$ so that the details of this experiment
	 * can be written to a file. If the user wishes to display output at runtime as
	 * well, simply set #displayExec to <tt>true<\tt>.
	 * 
	 * The way this method works is by calling #parametersIVPreprocess,
	 * #parametersIVFormatHead, #parametersIVComputeRegData,
	 * #parametersIVComputeCoefficients, and #parametersIVFormatCoefficients
	 * sequentially.
	 * 
	 * @param rqmcPts    the RQMC point sets to construct the observation.
	 * @param model      the underlying model, from which the observations are
	 *                   obtained.
	 * @param m          the number of independent repetitions.
	 * @param de         the histogram.
	 * @param hArray     the values for \f$h\f$ of the testing region.
	 * @param evalPoints the evaluation points used to estimate the empirical IV.
	 * @return a formatted String containing all the information about this
	 *         parameter estimation.
	 */
	public String parametersIVEstimate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de,
			double[] hArray, double[] evalPoints) {

		StringBuffer sb = new StringBuffer("");

		parametersIVPreprocess(rqmcPts, hArray);

		double[][] regDataX = new double[logIV3D.length][];

		sb.append(parametersIVFormatHead(rqmcPts[0].getLabel(), de.toString(), Integer.toString(evalPoints.length), m));

		sb.append(parametersIVComputeRegData(model, rqmcPts, m, de, hArray, regDataX, evalPoints));

		parametersIVComputeCoefficients(regDataX);

		sb.append(parametersIVFormatCoefficients());

		return sb.toString();

	}

	public String parametersIVEstimate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] hArray, double[] evalPoints) {

		StringBuffer sb = new StringBuffer("");

		parametersIVPreprocess(rqmcPts, hArray);

		double[][] regDataX = new double[logIV3D.length][];

		sb.append(parametersIVFormatHead(rqmcPts[0].getLabel(), de.toString(), Integer.toString(evalPoints.length), m));

		sb.append(parametersIVComputeRegData(model, rqmcPts, m, de, hArray, regDataX, evalPoints));

		parametersIVComputeCoefficients(regDataX);

		sb.append(parametersIVFormatCoefficients());

		return sb.toString();
	}

	public String parametersIVEstimate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEKernelDensity de,
			double[] hArray, double[] evalPoints) {

		StringBuffer sb = new StringBuffer("");

		parametersIVPreprocess(rqmcPts, hArray);

		double[][] regDataX = new double[logIV3D.length][];

		sb.append(parametersIVFormatHead(rqmcPts[0].getLabel(), de.toString(), Integer.toString(evalPoints.length), m));

		sb.append(parametersIVComputeRegData(model, rqmcPts, m, (DEKernelDensity) de, hArray, regDataX, evalPoints));

		parametersIVComputeCoefficients(regDataX);

		sb.append(parametersIVFormatCoefficients());

		return sb.toString();
	}

	/**
	 * Computes the roughness functional for the \a order -th derivative of the
	 * density of a normal distribution with parameters (\a mu,\a sigma) over
	 * \f$[a,b]\f$. As for now, only 3 and 4 are allowed values of \a order, any
	 * other will throw an exception.
	 * 
	 * @param order the order of the derivative. Must be 3 or 4.
	 * @param mu    the mean.
	 * @param sigma the standard deviation.
	 * @return the roughness functional for the \a order -th derivative of the
	 *         density of a normal distribution with parameters (\a mu,\a sigma).
	 */
	public double setInitRoughnessFunctional(int order, double mu, double sigma) {
		double result = 0.0;
		double sqrtPi = Math.sqrt(Math.PI);
		double aTerm = (mu - a) / sigma;
		double bTerm = (b - mu) / sigma;
		double pdfA = NormalDist.density(mu, sigma, a);
		double pdfB = NormalDist.density(mu, sigma, b);

		if (order == 4) {
			result = pdfA * pdfA * aTerm * (8.0 * Math.pow(aTerm, 6.0) - 68.0 * aTerm * aTerm * aTerm * aTerm
					+ 166.0 * aTerm * aTerm - 39.0);
			result += pdfB * pdfB * bTerm * (8.0 * Math.pow(bTerm, 6.0) - 68.0 * bTerm * bTerm * bTerm * bTerm
					+ 166.0 * bTerm * bTerm - 39.0);
			result *= -2.0 * sqrtPi * sigma * sigma;

			result += 105.0 * (NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (b - mu) + mu)
					- NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (a - mu) + mu));
			return result / (32.0 * sqrtPi * Math.pow(sigma, 9.0));
		}

		else if (order == 3) {

			result = pdfA * pdfA * aTerm * (4.0 * aTerm * aTerm * aTerm * aTerm - 14.0 * aTerm * aTerm + 15.0);
			result += pdfB * pdfB * bTerm * (4.0 * bTerm * bTerm * bTerm * bTerm - 14.0 * bTerm * bTerm + 15.0);
			result *= -2.0 * sqrtPi * sigma * sigma;

			result += 15.0 * (NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (b - mu) + mu)
					- NormalDist.cdf(mu, sigma, Math.sqrt(2.0) * (a - mu) + mu));
			return result / (16.0 * sqrtPi * Math.pow(sigma, 7.0));
		}

		else {
			throw new UnsupportedOperationException(
					"setInitRoughnessFunctional is not implemented for the order " + order);
		}
	}

	/**
	 * Estimates the parameter \f$B\f$ according to the formula from the table given
	 * above. This is done by generating \f$n\f$ observations of \a model with the
	 * RQMC points \a rqmc. It computes the empirical mean \f$\hat{\mu}\f$ and
	 * standard deviation \f$\hat{\sigma}\f$ of these observations and uses them to
	 * obtain an initial value for the roughness functional of the sought density of
	 * order \a order + 2 over \f$[a,b]\f$. This initial value is computed as the
	 * roughness functional of the density of a normal distribution with parameters
	 * \f$(ħat{\mu},\hat{\sigma})\f$. It then iterates once over the recursive
	 * formula for the optimal bin-/bandwidth given in \ref
	 * umontreal.ssj.stat.density.DensityDerivativeEstimator with
	 * umontreal.ssj.stat.density.DEDerivativeGaussian#hAmiseR. Using this optimal
	 * bin-/bandwidth, it estimates the derivative of order \a order of the sought
	 * density by a \ref umontreal.ssj.stat.density.DEDerivativeGaussian.
	 * 
	 * This procedure is repeated \f$m\f$ times, each time with \a rqmc randomized
	 * afresh and the mean of the result is set as \f$B\f$s.
	 * 
	 * Note that, for estimating B \a order has actually to be 1 or 2. This is
	 * implicitly assumed, as #setInitRoughnessFunctional would throw an exception
	 * here for any other order.
	 * 
	 * 
	 * 
	 * @param model      the underlying model.
	 * @param rqmc       the RQMC point set used.
	 * @param m          the number of independent replications.
	 * @param evalPoints the evaluation points to estimate the roughness
	 *                   functionals.
	 * @param order      the sought order of the derivative of the density. Has to
	 *                   be 1 or 2 for a histogram or a kernel density estimator,
	 *                   respectively.
	 * @param factor     the factor with which the respective roughness functional
	 *                   is multiplied to yield \f$B\f$. For a histogram this is 1/4
	 *                   and for a KDE 1/12.
	 */
	public void estimateB(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, double[] evalPoints, int order,
			double factor) {
		double[][] data = new double[m][];
		Tally statReps = new Tally();
		RQMCExperiment.simulReplicatesRQMC(model, rqmc, m, statReps, data);
		int n = rqmc.getNumPoints();

		DEDerivativeGaussian dde = new DEDerivativeGaussian(order);
		double[] muSigma = new double[2];
		double init;
		double h;
		double mu2Derivative = DensityDerivativeEstimator.densityFunctionalGaussian(order, 1.0);
		double[] density = new double[evalPoints.length];
		double rf = 0.0;

		for (int rep = 0; rep < m; rep++) {
			muSigma = estimateMeanAndStdDeviation(data[rep]);
			init = setInitRoughnessFunctional(order + 2, muSigma[0], muSigma[1]);
			h = DEDerivativeGaussian.hAmiseR(order, 1.0, mu2Derivative, init, n);
			dde.setH(h);
			dde.setData(data[rep]);
			density = dde.evalDensity(evalPoints);
			rf += DensityEstimator.roughnessFunctional(density, a, b);
		}

		rf /= (double) m;
		setB(factor * rf);
	}

	/**
	 * For parameter estimation of the ISB this method produces and returns a
	 * formatted string containing a head with basic information that can be used as
	 * a introductory head for the estimation of the ISB parameters.
	 * 
	 * @param pointLabel     short description of the RQMC point set.
	 * @param estimatorLabel short description of the estimator used.
	 * @param numEvalPoints  the number of evaluation points to compute the
	 *                       roughness functionals.
	 * @param m              number of independent replications.
	 * @param n              the number of points considered, i.e. the size of the
	 *                       point set.
	 * @return a formatted introductory head for the parameter estimation of the IV.
	 */
	public String parametersISBFormatHead(String pointLabel, String estimatorLabel, int numEvalPoints, int m, int n) {
		StringBuffer sb = new StringBuffer("");
		sb.append("Model parameter estimation for the ISB over the interval [" + a + ", " + b + "]\n");
		sb.append("----------------------------------------------------------------\n\n");
		sb.append("Estimator: " + estimatorLabel + "\n");
		sb.append("Point set used: " + pointLabel + "\n");
		sb.append("Number of points: " + n + "\n");
		sb.append("Number of repititions: m = " + m + "\n");
		sb.append("Evaluation points: " + numEvalPoints + "\n");
		sb.append("----------------------------------------------------------------\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	/**
	 * Gives the current values of the parameters \f$\alpha\f$ and \f$B\f$ as
	 * formatted string.
	 * 
	 * @return the ISB parameters in a formatted string.
	 */
	public String parametersISBFormatCoefficients() {
		String str = "ISB-parameters:\n";
		str += "-------------------------------------\n";
		str += "alpha =\t" + getAlpha() + "\n";
		str += "B =\t" + getB() + "\n\n";
		if (displayExec)
			System.out.print(str);
		return str;
	}

	/**
	 * Carries out the estimation of the parameter \f$B\f$ in the ISB for a \ref
	 * DEKernelDensity. More precisely, it sets the necessary parameters to compute
	 * the estimate \f$B\f$ an then calls #estimateB.
	 * 
	 * @param model      the underlying model.
	 * @param rqmc       the RQMC point set used.
	 * @param m          the number of independent replications.
	 * @param de         the kernel density estimator.
	 * @param evalPoints the evaluation points used to estimate the roughness
	 *                   functionals.
	 * @return a formatted string summarizing the results for the estimation of the
	 *         parameter \f$B\f$.
	 */
	public String parametersISBEstimate(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, DEKernelDensity de,
			double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");

		sb.append(parametersISBFormatHead(rqmc.getLabel(), "Kernel density estimator", evalPoints.length, m,
				rqmc.getNumPoints()));

		int order = 2;
		double factor = 0.25;

		estimateB(model, rqmc, m, evalPoints, order, factor);

		sb.append(parametersISBFormatCoefficients());

		return sb.toString();
	}

	/**
	 * Same as above, but for histograms.
	 * 
	 * @param model      the underlying model.
	 * @param rqmc       the RQMC point set used.
	 * @param m          the number of independent replications.
	 * @param de         the kernel density estimator.
	 * @param evalPoints the evaluation points used to estimate the roughness
	 *                   functionals.
	 * @return a formatted string summarizing the results for the estimation of the
	 *         parameter \f$B\f$.
	 */
	public String parametersISBEstimate(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, DEHistogram de,
			double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");

		sb.append(parametersISBFormatHead(rqmc.getLabel(), "Histogram", evalPoints.length, m, rqmc.getNumPoints()));

		int order = 1;
		double factor = 1.0 / 12.0;

		estimateB(model, rqmc, m, evalPoints, order, factor);

		sb.append(parametersISBFormatCoefficients());

		return sb.toString();
	}

	public String parametersISBEstimate(MonteCarloModelDouble model, RQMCPointSet rqmc, int m, DensityEstimator de,
			double[] evalPoints) {
		throw new UnsupportedOperationException(
				"parametersISBEstimate is not implemented for the DensityEstimator " + de.toString());
	}

	/**
	 * Provides a formatted string summarizing the results of the estimation of the
	 * MISE-related coefficients @f$\gamma, \kappa, K, \nu@f$.
	 * 
	 * @return a formatted string for estimation of the MISE-related coefficients.
	 */
	public String parametersMISEFormatCoefficients() {
		StringBuffer sb = new StringBuffer("");
		sb.append("MISE-parameters: \n");
		sb.append("-------------------------------------\n");
		sb.append("gamma =\t" + getGamma() + "\n");
		sb.append("kappa =\t" + getKappa() + "\n");
		sb.append("K =\t" + getK() + "\n");
		sb.append("nu =\t" + getNu() + "\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	/**
	 * For parameter estimation of the MISE this method produces a formatted string
	 * carrying basic information that can be used as a introductory head for the
	 * estimation of the MISE parameters.
	 *
	 * @param pointLabel     a description of the point set employed.
	 * @param estimatorLabel a description of the density estimator.
	 * @param numEvalPoints  the number of evaluation points to estimate the
	 *                       empirical MISE
	 * @param m              the number of independent replications of the
	 *                       observations.
	 * @return a formatted introductory head for the parameter estimation of the
	 *         MISE.
	 */
	public String estimateMISEOptHFormatHead(String pointLabel, String estimatorLabel, String numEvalPoints, int m) {
		StringBuffer sb = new StringBuffer("");
		sb.append("Estimation of MISE rate with optimal h over [" + a + ", " + b + "]\n");
		sb.append("----------------------------------------------------------------\n\n");
		sb.append("Estimator: " + estimatorLabel + "\n");
		sb.append("Point set used: " + pointLabel + "\n");
		sb.append("Number of repititions: m = " + m + "\n");
		sb.append("Evaluation points: " + numEvalPoints + "\n");
		sb.append("----------------------------------------------------------------\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	/**
	 * Same as above, but for when the number of evaluation points is not fixed.
	 * This is, for instance, useful histograms, where it sometimes does not make
	 * sense to evaluate the density more than once in one bin.
	 * 
	 * @param pointLabel     a description of the point set employed.
	 * @param estimatorLabel a description of the density estimator.
	 * @param m              the number of independent replications of the
	 *                       observations.
	 * @return a formatted introductory head for the parameter estimation of the
	 *         MISE.
	 */
	public String estimateMISEOptHFormatHead(String pointLabel, String estimatorLabel, int m) {
		return estimateMISEOptHFormatHead(pointLabel, estimatorLabel, "variable", m);
	}

	/**
	 * On the basis of the previously estimated model parameters with the RQMC
	 * points \a rqmcPts, this function takes care of several initializations,
	 * including setting the optimal bandwith for each point set in \a rqmcPts.
	 * 
	 * @param rqmcPts the RQMC point set for which the model parameters had been
	 *                estimated.
	 */
	public void estimateMISEOptHPreprocess(RQMCPointSet[] rqmcPts) {
		logN = new double[rqmcPts.length];
		logHOpt = new double[logN.length];
		for (int i = 0; i < rqmcPts.length; i++) {
			logN[i] = Math.log((double) rqmcPts[i].getNumPoints()) / logOfBase;
			logHOpt[i] = Math.log(getKappa()) / logOfBase - getGamma() * logN[i];
		}
		logEstIV = new double[logN.length];
		logEstISB = new double[logN.length];
		logEstMISE = new double[logN.length];
		for (int i = 0; i < logN.length; i++) {
			logEstIV[i] = estimateLogIV(logHOpt[i], logN[i]);
			logEstISB[i] = estimateLogISB(logHOpt[i]);
			logEstMISE[i] = estimateLogMISE(logN[i]);
		}

		logIV = new double[logN.length];
		logMISE = new double[logN.length];
	}

	/**
	 * Once the parameters have been estimated and all necessary initialization have
	 * been made (via #estimateMISEOptHPreprocess, for instance), this function
	 * re-runs the experiment with the estimated optimal bandwiths that had been
	 * obtained with the RQMC point sets \a rqmcPts. In doing so, it estimates the
	 * IV, the ISB, as well as the MISE, and returns a report on the experiment.
	 * 
	 * @param model      the underlying model.
	 * @param rqmcPts    the point sets used for the experiment.
	 * @param m          the number of independent repetitions.
	 * @param de         the KDE used in this experiment.
	 * @param evalPoints the number of evaluation points.
	 * @return a formatted String summarizing the results of this experiment.
	 */
	public String estimateMISEOptHComputeTable(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m,
			DEKernelDensity de, double[] evalPoints) {

		StringBuffer sb = new StringBuffer("");
		String str;

		str = "log(n)\t log(h*)\t estimated log(IV)\t estimated log(ISB)\t estimated log(MISE) \t empirical log(IV) \t empirical log(MISE)\n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		Tally statReps = new Tally();
		double[][] data = new double[m][];
		double[][] density;
		double[] variance;

		for (int i = 0; i < rqmcPts.length; i++) {// rqmc point sets indexed by i

			RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
			setH(de, Math.pow(baseOfLog, logHOpt[i]));
			density = new double[m][evalPoints.length];
			density = de.evalDensity(evalPoints, data);

			variance = new double[evalPoints.length];

			logIV[i] = Math.log(DensityEstimator.computeIV(density, a, b, variance)) / logOfBase;
			logMISE[i] = Math.log(Math.pow(baseOfLog, logIV[i]) + Math.pow(baseOfLog, logEstISB[i])) / logOfBase;

			str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(8, 6, logHOpt[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstIV[i]) + "\t\t " + PrintfFormat.f(8, 6, logEstISB[i]) + "\t\t "
					+ PrintfFormat.f(8, 6, logEstMISE[i]) + "\t\t " + PrintfFormat.f(8, 6, logIV[i]) + "\t\t "
					+ PrintfFormat.f(8, 6, logMISE[i]) + "\n";

			sb.append(str);
			if (displayExec)
				System.out.print(str);

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();

	}

	/**
	 * Same as above, but for Histograms.
	 * 
	 * @param model      the underlying model.
	 * @param rqmcPts    the point sets used for the experiment.
	 * @param m          the number of independent repetitions.
	 * @param de         the Histogram used in this experiment.
	 * @param evalPoints the number of evaluation points.
	 * @return a formatted String summarizing the results of this experiment.
	 */
	public String estimateMISEOptHComputeTable(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m,
			DEHistogram de) {

		StringBuffer sb = new StringBuffer("");
		String str;

		str = "log(n)\t log(h*)\t estimated log(IV)\t estimated log(ISB)\t estimated log(MISE) \t empirical log(IV) \t empirical log(MISE)\n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		Tally statReps = new Tally();
		double[][] data = new double[m][];
		double[][] density;
		double[] variance;
		int numBins;
		double h;

		for (int i = 0; i < rqmcPts.length; i++) {// rqmc point sets indexed by i

			RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
			h = Math.pow(baseOfLog, logHOpt[i]);
			numBins = (int) ((b - a) / h);

			density = new double[m][numBins];
			density = DEHistogram.evalDensity(data, a, b, numBins);

			// setH(de,Math.pow(baseOfLog, logHOpt[i]));
			// density = new double[m][de.getNumBins()];
			// density = DEHistogram.evalDensity(data, a, b,de.getNumBins());

			variance = new double[numBins];

			logIV[i] = Math.log(DensityEstimator.computeIV(density, a, b, variance)) / logOfBase;
			logMISE[i] = Math.log(Math.pow(baseOfLog, logIV[i]) + Math.pow(baseOfLog, logEstISB[i])) / logOfBase;

			str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(8, 6, logHOpt[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstIV[i]) + "\t\t " + PrintfFormat.f(8, 6, logEstISB[i]) + "\t\t "
					+ PrintfFormat.f(8, 6, logEstMISE[i]) + "\t\t " + PrintfFormat.f(8, 6, logIV[i]) + "\t\t "
					+ PrintfFormat.f(8, 6, logMISE[i]) + "\n";

			sb.append(str);
			if (displayExec)
				System.out.print(str);

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();

	}

	/**
	 * Same as above, the default method for any density estimator.
	 * 
	 * @param model      the underlying model.
	 * @param rqmcPts    the point sets used for the experiment.
	 * @param m          the number of independent repetitions.
	 * @param de         the KDE used in this experiment.
	 * @param evalPoints the number of evaluation points.
	 * @return a formatted String summarizing the results of this experiment.
	 */
	public String estimateMISEOptHComputeTable(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m,
			DensityEstimator de, double[] evalPoints) {

		StringBuffer sb = new StringBuffer("");
		String str;

		str = "log(n)\t log(h*)\t estimated log(IV)\t estimated log(ISB)\t estimated log(MISE) \t empirical log(IV) \t empirical log(MISE)\n\n";

		sb.append(str);
		if (displayExec)
			System.out.print(str);

		Tally statReps = new Tally();
		double[][] data = new double[m][];
		double[][] density;
		double[] variance;

		for (int i = 0; i < rqmcPts.length; i++) {// rqmc point sets indexed by i

			RQMCExperiment.simulReplicatesRQMC(model, rqmcPts[i], m, statReps, data);
			setH(de, Math.pow(baseOfLog, logHOpt[i]));
			density = new double[m][evalPoints.length];
			density = de.evalDensity(evalPoints, data);

			variance = new double[evalPoints.length];

			logIV[i] = Math.log(DensityEstimator.computeIV(density, a, b, variance)) / logOfBase;
			logMISE[i] = Math.log(Math.pow(baseOfLog, logIV[i]) + Math.pow(baseOfLog, logEstISB[i])) / logOfBase;

			str = PrintfFormat.f(3, 1, logN[i]) + "\t " + PrintfFormat.f(8, 6, logHOpt[i]) + "\t "
					+ PrintfFormat.f(8, 6, logEstIV[i]) + "\t\t " + PrintfFormat.f(8, 6, logEstISB[i]) + "\t\t "
					+ PrintfFormat.f(8, 6, logEstMISE[i]) + "\t\t " + PrintfFormat.f(8, 6, logIV[i]) + "\t\t "
					+ PrintfFormat.f(8, 6, logMISE[i]) + "\n";

			sb.append(str);
			if (displayExec)
				System.out.print(str);

		}

		str = "\n\n";
		sb.append(str);
		if (displayExec)
			System.out.print(str);

		return sb.toString();

	}

	/**
	 * Computes the coefficient of determination @f$R^2@f$ for the IV for the re-run
	 * with the optimal bandwidth and returns the results in a formatted string.
	 * 
	 * @return a formatted string for the @f$R^2@f$ of the IV.
	 */
	public String estimateMISEOptHRsqIV() {
		String str = "Coefficient of determination:\n";
		str += "********************************************\n\n";
		str += "R^2 for IV: " + coefficientOfDetermination(logIV, logEstIV) + "\n\n";
		if (displayExec)
			System.out.print(str);
		return str;
	}

	/**
	 * In the re-run of the experiment with the optimal bandwidth, this function
	 * computes the convergence rates of the estimated IV and of the estimated MISE
	 * and returns them in a formatted string.
	 * 
	 * @return a formatted string for the convergence rates of the IV and the MISE.
	 */
	public String estimateMISEOptHSlopes() {
		double[] regCoeffs = new double[2];

		String str = "Regression data:\n";
		str += "********************************************\n\n";
		str += "IV:\n";

		regCoeffs = LeastSquares.calcCoefficients(logN, logIV);
		str += "Slope:\t" + regCoeffs[1] + "\n";
		str += "Const.:\t" + regCoeffs[0] + "\n\n";
		str += "MISE:\n";
		regCoeffs = LeastSquares.calcCoefficients(logN, logMISE);
		str += "Slope:\t" + regCoeffs[1] + "\n";
		str += "Const.:\t" + regCoeffs[0] + "\n\n";

		if (displayExec)
			System.out.print(str);
		return str;
	}

	/**
	 * This function takes care of the entire procedure of estimating the MISE with
	 * a KDE using the estimated optimal bandwidth. The results are summarized and
	 * returned as a formatted string.
	 * 
	 * @param model      the underlying model.
	 * @param rqmcPts    the RQMC point sets used.
	 * @param m          the number of independent repetitions.
	 * @param de         the KDE for the experiments.
	 * @param evalPoints the evaluation points.
	 * @return a formatted string summarizing the experiment.
	 */
	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEKernelDensity de,
			double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");
		sb.append(estimateMISEOptHFormatHead(rqmcPts[0].getLabel(), de.toString(), Integer.toString(evalPoints.length),
				m));
		estimateMISEOptHPreprocess(rqmcPts);
		sb.append(estimateMISEOptHComputeTable(model, rqmcPts, m, (DEKernelDensity) de, evalPoints));
		sb.append(estimateMISEOptHRsqIV());
		sb.append(estimateMISEOptHSlopes());

		return sb.toString();
	}

	/**
	 * Same as above for a Histogram. Note that no evaluation points are needed in
	 * this case, as evaluating the histogram more than once in each bin is not
	 * necessary.
	 * 
	 * @param model   the underlying model.
	 * @param rqmcPts the RQMC point sets used.
	 * @param m       the number of independent repetitions.
	 * @param de      the histogram for the experiments.
	 * @return a formatted string summarizing the experiment.
	 */
	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de) {
		StringBuffer sb = new StringBuffer("");
		sb.append(estimateMISEOptHFormatHead(rqmcPts[0].getLabel(), "Histogram", m));
		estimateMISEOptHPreprocess(rqmcPts);
		sb.append(estimateMISEOptHComputeTable(model, rqmcPts, m, de));
		sb.append(estimateMISEOptHRsqIV());
		sb.append(estimateMISEOptHSlopes());

		return sb.toString();
	}

	/**
	 * Same as above. Note that \a evalPoints is only a placeholder to fit the same
	 * structure used for other estimators. The histogram will be evaluated once in
	 * each bin.
	 * 
	 * @param model      the underlying model.
	 * @param rqmcPts    the RQMC point sets used.
	 * @param m          the number of independent repetitions.
	 * @param de         the histogram for the experiments.
	 * @param evalPoints dummy argument.
	 * @return a formatted string summarizing the experiment.
	 */
	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] evalPoints) {
		return estimateMISEOptH(model, rqmcPts, m, de);
	}

	/**
	 * Same as above for arbitrary density estimators.
	 * 
	 * @param model      the underlying model.
	 * @param rqmcPts    the RQMC point sets used.
	 * @param m          the number of independent repetitions.
	 * @param de         the KDE for the experiments.
	 * @param evalPoints the evaluation points.
	 * @return a formatted string summarizing the experiment.
	 */
	public String estimateMISEOptH(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de,
			double[] evalPoints) {
		StringBuffer sb = new StringBuffer("");
		sb.append(estimateMISEOptHFormatHead(rqmcPts[0].getLabel(), de.toString(), Integer.toString(evalPoints.length),
				m));
		estimateMISEOptHPreprocess(rqmcPts);
		sb.append(estimateMISEOptHComputeTable(model, rqmcPts, m, de, evalPoints));
		sb.append(estimateMISEOptHRsqIV());
		sb.append(estimateMISEOptHSlopes());

		return sb.toString();
	}

	/**
	 * Returns in a formatted string some basic information about the experiment.
	 * 
	 * @param model the underlying model.
	 * @return a formatted string with some information about the experiment.
	 */
	public String testMISERateFormatHead(MonteCarloModelDouble model) {
		StringBuffer sb = new StringBuffer("");
		sb.append("DENSITY ESTIMATION\n");
		sb.append("************************************************\n");
		sb.append("Density estimation with the bandwidth-based parametric model for\n");
		sb.append(model.toString());
		sb.append("----------------------------------------------------------------\n\n");
		if (displayExec)
			System.out.print(sb.toString());
		return sb.toString();
	}

	/**
	 * Carries out the entire experiment to estimate all the model coefficients
	 * using a KDE. The results are summarized and returned in a formatted string.
	 * 
	 * @param model            the underlying model.
	 * @param rqmcPts          the RQMC point sets used.
	 * @param m                the number of independent repetitions.
	 * @param de               the KDE used.
	 * @param hArray           an array containing the pre-selected bandwidths.
	 * @param evalPoints       the evaluation points.
	 * @param genSinglePlots2D whether to generate several 2D plots or not.
	 * @return a formatted string summarizing the results of this experiment.
	 * @throws IOException
	 */
	public String testMISERate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEKernelDensity de,
			double[] hArray, double[] evalPoints, boolean genSinglePlots2D) throws IOException {
		StringBuffer sb = new StringBuffer("");
		sb.append(testMISERateFormatHead(model));

		sb.append(parametersIVEstimate(model, rqmcPts, m, (DEKernelDensity) de, hArray, evalPoints));
		sb.append(parametersISBEstimate(model, rqmcPts[rqmcPts.length - 1], m, de, evalPoints));
		sb.append(parametersMISEFormatCoefficients());
		sb.append(estimateMISEOptH(model, rqmcPts, m, de, evalPoints));

		if (producePlots) {
			genPlots3D((model.toString()).split(" ")[0], (de.toString()).split(" ")[0], rqmcPts[0].getLabel());
			if (genSinglePlots2D)
				genPlots2D((model.toString()).split(" ")[0], (de.toString()).split(" ")[0], rqmcPts[0].getLabel());
		}

		return sb.toString();
	}

	/**
	 * Same as above, but for a histogram. Note that for the estimation of the IV,
	 * the histogram is evaluated only once in each bin.
	 * 
	 * @param model            the underlying model.
	 * @param rqmcPts          the RQMC point sets used.
	 * @param m                the number of independent repetitions.
	 * @param de               the histogram used.
	 * @param hArray           an array containing the pre-selected bandwidths.
	 * @param evalPoints       the evaluation points.
	 * @param genSinglePlots2D whether to generate several 2D plots or not.
	 * @return a formatted string summarizing the results of this experiment.
	 * @throws IOException
	 */
	public String testMISERate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DEHistogram de,
			double[] hArray, double[] evalPoints, boolean genSinglePlots2D) throws IOException {
		StringBuffer sb = new StringBuffer("");
		sb.append(testMISERateFormatHead(model));

		sb.append(parametersIVEstimate(model, rqmcPts, m, (DEHistogram) de, hArray, evalPoints));
		sb.append(parametersISBEstimate(model, rqmcPts[rqmcPts.length - 1], m, de, evalPoints));
		sb.append(parametersMISEFormatCoefficients());
		sb.append(estimateMISEOptH(model, rqmcPts, m, de, evalPoints));

		if (producePlots) {
			genPlots3D((model.toString()).split(" ")[0], (de.toString()).split(" ")[0], rqmcPts[0].getLabel());
			if (genSinglePlots2D)
				genPlots2D((model.toString()).split(" ")[0], (de.toString()).split(" ")[0], rqmcPts[0].getLabel());
		}

		return sb.toString();
	}

	/**
	 * Same as above for a generic density estimator.
	 * 
	 * @param model            the underlying model.
	 * @param rqmcPts          the RQMC point sets used.
	 * @param m                the number of independent repetitions.
	 * @param de               the density estimator used.
	 * @param hArray           an array containing the pre-selected bandwidths.
	 * @param evalPoints       the evaluation points.
	 * @param genSinglePlots2D whether to generate several 2D plots or not.
	 * @return a formatted string summarizing the results of this experiment.
	 * @throws IOException
	 */
	public String testMISERate(MonteCarloModelDouble model, RQMCPointSet[] rqmcPts, int m, DensityEstimator de,
			double[] hArray, double[] evalPoints, boolean genSinglePlots2D) throws IOException {
		StringBuffer sb = new StringBuffer("");
		sb.append(testMISERateFormatHead(model));

		sb.append(parametersIVEstimate(model, rqmcPts, m, de, hArray, evalPoints));
		sb.append(parametersISBEstimate(model, rqmcPts[rqmcPts.length - 1], m, de, evalPoints));
		sb.append(parametersMISEFormatCoefficients());
		sb.append(estimateMISEOptH(model, rqmcPts, m, de, evalPoints));

		if (producePlots) {
			genPlots3D((model.toString()).split(" ")[0], (de.toString()).split(" ")[0], rqmcPts[0].getLabel());
			if (genSinglePlots2D)
				genPlots2D((model.toString()).split(" ")[0], (de.toString()).split(" ")[0], rqmcPts[0].getLabel());
		}

		return sb.toString();
	}

	/**
	 * Same as #testMISERate for a KDE but the experiment will be executed for each
	 * type of RQMC point set provided in \a rqmcPtsList. Several 2-dimensional
	 * plots related to the experiment will be produced automatically.
	 * 
	 * @param model       the underlying model.
	 * @param rqmcPtsList a list of arrays of different types of RQMC points. Each
	 *                    array contains one type of point set with varying \f$n\f$.
	 * @param m           the number of independent repetitions.
	 * @param de          the KDE used.
	 * @param hArray      an array containing the pre-selected bandwidths.
	 * @param evalPoints  the evaluation points.
	 * @return a formatted string summarizing the results of this experiment.
	 */
	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m,
			DEKernelDensity de, double[] hArray, double[] evalPoints) throws IOException {
		StringBuffer sb = new StringBuffer("");
		ArrayList<PgfDataTable> pgfTblList = new ArrayList<PgfDataTable>();
		for (RQMCPointSet[] rqmcPts : rqmcPtsList) {
			sb.append(testMISERate(model, rqmcPts, m, de, hArray, evalPoints, true));
			if (producePlots)
				pgfTblList.add(genPgfDataTable(rqmcPts[0].getLabel(), rqmcPts[0].getLabel()));
		}

		return sb.toString();
	}

	/**
	 * Same as above for a histogram.
	 * 
	 * @param model       the underlying model.
	 * @param rqmcPtsList a list of arrays of different types of RQMC points. Each
	 *                    array contains one type of point set with varying \f$n\f$.
	 * @param m           the number of independent repetitions.
	 * @param de          the histogram used.
	 * @param hArray      an array containing the pre-selected bandwidths.
	 * @param evalPoints  the evaluation points.
	 * @return a formatted string summarizing the results of this experiment.
	 */
	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m,
			DEHistogram de, double[] hArray, double[] evalPoints) throws IOException {
		StringBuffer sb = new StringBuffer("");
		ArrayList<PgfDataTable> pgfTblList = new ArrayList<PgfDataTable>();
		for (RQMCPointSet[] rqmcPts : rqmcPtsList) {
			sb.append(testMISERate(model, rqmcPts, m, de, hArray, evalPoints, true));
			if (producePlots)
				pgfTblList.add(genPgfDataTable(rqmcPts[0].getLabel(), rqmcPts[0].getLabel()));
		}

		return sb.toString();
	}

	/**
	 * Same as above for a generic density estimator.
	 * 
	 * @param model       the underlying model.
	 * @param rqmcPtsList a list of arrays of different types of RQMC points. Each
	 *                    array contains one type of point set with varying \f$n\f$.
	 * @param m           the number of independent repetitions.
	 * @param de          the density estimator used.
	 * @param hArray      an array containing the pre-selected bandwidths.
	 * @param evalPoints  the evaluation points.
	 * @return a formatted string summarizing the results of this experiment.
	 */
	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m,
			DensityEstimator de, double[] hArray, double[] evalPoints) throws IOException {
		StringBuffer sb = new StringBuffer("");
		ArrayList<PgfDataTable> pgfTblList = new ArrayList<PgfDataTable>();
		for (RQMCPointSet[] rqmcPts : rqmcPtsList) {
			sb.append(testMISERate(model, rqmcPts, m, de, hArray, evalPoints, true));
			if (producePlots)
				pgfTblList.add(genPgfDataTable(rqmcPts[0].getLabel(), rqmcPts[0].getLabel()));
		}

		return sb.toString();
	}

	/**
	 * Executes the experiments for all density estimators listed in \a deList and
	 * all types of RQMC point sets provided in \a rqmcPtsList.
	 * 
	 * @param model       the underlying model.
	 * @param rqmcPtsList a list of arrays of different types of RQMC points. Each
	 *                    array contains one type of point set with varying \f$n\f$.
	 * @param m           the number of independent repetitions.
	 * @param deList      a list containing the density estimators.
	 * @param hArray      an array containing the pre-selected bandwidths.
	 * @param evalPoints  the evaluation points.
	 * @return a formatted string summarizing the results of this experiment.
	 * @throws IOException
	 */
	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m,
			ArrayList<DensityEstimator> deList, double[] hArray, double[] evalPoints) throws IOException {
		StringBuffer sb = new StringBuffer("");
		for (DensityEstimator de : deList)
			sb.append(testMISERate(model, rqmcPtsList, m, de, hArray, evalPoints));
		return sb.toString();
	}

	/**
	 * Executes the experiments for all density estimators listed in \a deList and
	 * all types of RQMC point sets provided in \a rqmcPtsList. For each density
	 * estimator, a different set of bandwiths is provided in \a hArrayList
	 * 
	 * @param model       the underlying model.
	 * @param rqmcPtsList a list of arrays of different types of RQMC points. Each
	 *                    array contains one type of point set with varying \f$n\f$.
	 * @param m           the number of independent repetitions.
	 * @param deList      a list containing the density estimators.
	 * @param hArrayList  a list of bandwiths corresponding to the estimators in \a
	 *                    deList.
	 * @param evalPoints  the evaluation points.
	 * @return a formatted string summarizing the results of this experiment.
	 * @throws IOException
	 */
	public String testMISERate(MonteCarloModelDouble model, ArrayList<RQMCPointSet[]> rqmcPtsList, int m,
			ArrayList<DensityEstimator> deList, ArrayList<double[]> hArrayList, double[] evalPoints)
			throws IOException {
		StringBuffer sb = new StringBuffer("");
		int len = deList.size();
		for (int l = 0; l < len; l++)
			sb.append(testMISERate(model, rqmcPtsList, m, deList.get(l), hArrayList.get(l), evalPoints));
		return sb.toString();
	}

	/**
	 * Produces the PgfDataTable for the linear model, i.e., the estimated IV over
	 * the grid of selected pairs @f$(n,h)@f$.
	 * 
	 * @param tableName
	 * @param tableLabel
	 * @return
	 */
	public PgfDataTable genPgfDataTable3D(String tableName, String tableLabel) {
		int len = logN.length * logH.length;
		int index;
		double[][] pgfData = new double[len][4];
		for (int i = 0; i < logN.length; i++) {
			for (int j = 0; j < logH.length; j++) {
				index = i * logH.length + j;
				pgfData[index][0] = logN[i];
				pgfData[index][1] = logH[j];
				pgfData[index][2] = logIV3D[index];
				pgfData[index][3] = estimateLogIV(logH[j], logN[i]);
			}
		}
		return new PgfDataTable(tableName, tableLabel, tableFields3D, pgfData);

	}

	/**
	 * Produces the PgfDataTable for the experiments with the optimal bandwidth.
	 * 
	 * @param tableName
	 * @param tableLabel
	 * @return
	 */
	public PgfDataTable genPgfDataTable(String tableName, String tableLabel) {
		int len = logN.length;
		double[][] pgfData = new double[len][tableFields.length];
		for (int i = 0; i < len; i++) {
			pgfData[i][0] = logN[i];
			pgfData[i][1] = logIV[i];
			pgfData[i][2] = logMISE[i];
			pgfData[i][3] = logEstIV[i];
			pgfData[i][4] = logEstISB[i];
			pgfData[i][5] = logEstMISE[i];
		}
		return new PgfDataTable(tableName, tableLabel, tableFields, pgfData);
	}

	/**
	 * Produces several 2-dimensional plots for the experiments with the optimal
	 * bandwidths using the internally stored data from the last experiments.
	 * 
	 * @param modelDescr    short description of the model.
	 * @param deDescr       short description of the density estimator.
	 * @param pointSetDescr short description of the point set.
	 * @throws IOException
	 */
	public void genPlots2D(String modelDescr, String deDescr, String pointSetDescr) throws IOException {
		FileWriter fw;
		String plotBody;

		PgfDataTable pgfTbl = genPgfDataTable(modelDescr + "-" + deDescr + "-" + pointSetDescr, "2D-traits");

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_IVoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Empirical log(IV) with opt. h", "axis", 0, 1, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_MISEoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Empirical log(MISE) with opt. h", "axis", 0, 2, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_estIVoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Modelled log(IV) with opt. h", "axis", 0, 3, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_estISBoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Modelled log(ISB) with opt. h", "axis", 0, 4, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_estMISEoptH.tex");
		plotBody = pgfTbl.drawPgfPlotSingleCurve("Modelled log(MISE) with opt. h", "axis", 0, 5, (int) baseOfLog, "",
				" ");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();
	}

	/**
	 * * Produces several 2-dimensional plots for the experiments with the optimal
	 * bandwidths using the data provided in \a pgfTblList.
	 * 
	 * @param modelDescr short description of the model.
	 * @param deDescr    short description of the density estimator.
	 * @param pgfTblList list of PgfDataTables containing the data for the plots.
	 * @throws IOException
	 */
	public void genPlots2D(String modelDescr, String deDescr, ArrayList<PgfDataTable> pgfTblList) throws IOException {
		FileWriter fw;
		String plotBody;

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Empirical log(IV) with opt. h", "axis", 0, 1, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_IVoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Empirical log(MISE) with opt. h", "axis", 0, 2, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_MISEoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Modelled log(IV) with opt. h", "axis", 0, 3, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_estIVoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Modelled log(ISB) with opt. h", "axis", 0, 4, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_estISBoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();

		plotBody = PgfDataTable.drawPgfPlotManyCurves("Modelled log(MISE) with opt. h", "axis", 0, 5, pgfTblList,
				(int) baseOfLog, "", " ");
		fw = new FileWriter(modelDescr + "_" + deDescr + "_estMISEoptH.tex");
		fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
		fw.close();
	}

	/**
	 * Produces two 3-dimensional plots for the linear model, one for the empirical
	 * IV over the grid of selected @f$(n,n)@f$ and one for the estimated IV
	 * according to the linear model using the estimated
	 * parameters @f$C,\beta,\delta@f$.
	 * 
	 * @param modelDescr
	 * @param deDescr
	 * @param pointSetDescr
	 */
	public void genPlots3D(String modelDescr, String deDescr, String pointSetDescr) {
		String plotOptions = "mesh/rows=" + logN.length + ", " + "mesh/cols=" + logH.length;
		PgfDataTable pgfTbl = genPgfDataTable3D(modelDescr + "-" + deDescr + "-" + pointSetDescr, "3D-traits");
		String plotBody = pgfTbl.drawPgfPlotSingleCurve("Empirical log(IV) over test-grid with " + pointSetDescr,
				"axis", 0, 1, 2, (int) baseOfLog, plotOptions, " surf, faceted color=red");
		try {
			FileWriter fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_IV3D.tex");
			fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
			fw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

		plotBody = pgfTbl.drawPgfPlotSingleCurve("Estimated log(IV) over test-grid with " + pointSetDescr, "axis", 0, 1,
				3, (int) baseOfLog, plotOptions, " surf, faceted color=red");

		try {
			FileWriter fw = new FileWriter(modelDescr + "_" + deDescr + "_" + pointSetDescr + "_estIV3D.tex");
			fw.write(PgfDataTable.pgfplotFileHeader() + plotBody + PgfDataTable.pgfplotEndDocument());
			fw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Computes the mean and the standard deviation of the observations given in \a
	 * data.
	 * 
	 * 
	 * @param data the observations.
	 * @return the mean and standard deviation.
	 */

	private static double[] estimateMeanAndStdDeviation(double[] data) {
		double[] result = new double[2];
		int n = data.length;
		double x, y;

		double mean = 0.0;
		double var = 0.0;
		for (int i = 0; i < n; i++) {
			x = data[i];
			y = x - mean;
			mean += y / ((double) (i + 1.0));
			var += y * (x - mean);
		}

		result[0] = mean;
		result[1] = Math.sqrt(var / ((double) n - 1.0));
		return result;
	}

	/**
	 * Computes the coefficient of determination, \f$R^2\f$, w.r.t. \a data and \a
	 * dataEstimated.
	 * 
	 * @param data          the true data.
	 * @param dataEstimated the estimated data.
	 * @return the coefficient of determination.
	 */
	private static double coefficientOfDetermination(double[] data, double[] dataEstimated) {
		int i;
		int max = data.length;
		double maxInv = 1.0 / (double) max;
		double dataMean = 0.0;
		double SSres = 0.0;
		double SStot = 0.0;
		for (i = 0; i < max; i++)
			dataMean += data[i];
		dataMean *= maxInv;
		for (i = 0; i < max; i++) {
			SSres += (data[i] - dataEstimated[i]) * (data[i] - dataEstimated[i]);
			SStot += (data[i] - dataMean) * (data[i] - dataMean);
		}
		return 1.0 - SSres / SStot;
	}

	private static double[] genEvalPoints(int numPts, double a, double b, RandomStream stream) {
		double[] evalPts = new double[numPts];
		double invNumPts = 1.0 / ((double) numPts);
		for (int i = 0; i < numPts; i++)
			evalPts[i] = a + (b - a) * ((double) i + stream.nextDouble()) * invNumPts;
		return evalPts;
	}

	public static void main(String[] args) throws IOException {

		/*
		 ***************** UTIL PARAMETERS
		 ****************************************/

		RandomStream noise = new MRG32k3a();
		int mink = 14; // first log(N) considered
		int i;
		int m = 100; // m=20;// Number of RQMC randomizations.
		// int[] N = { 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144,
		// 524288, 1048576, 2097152 }; // 13
		int[] N = { 16384, 32768, 65536, 131072, 262144, 524288 };
		int numSets = N.length; // Number of sets in the series.
		double[][] data = new double[m][];

		// 0.6^k
		int[][] aa = {
				{ 1, 3455, 1967, 1029, 2117, 3871, 533, 2411, 1277, 2435, 1723, 3803, 1469, 569, 1035, 3977, 721, 797,
						297, 1659 }, // 13

				{ 1, 6915, 3959, 7743, 3087, 5281, 6757, 3369, 7107, 6405, 7753, 1641, 3613, 1819, 5827, 2087, 4417,
						6909, 5623, 4739 }, // 14

				{ 1, 12031, 14297, 677, 6719, 15787, 10149, 7665, 1017, 2251, 12105, 2149, 16273, 14137, 8179, 6461,
						15051, 6593, 12763, 8497 }, // 15

				{ 1, 19463, 8279, 14631, 12629, 26571, 30383, 1337, 6431, 3901, 12399, 20871, 5175, 3111, 26857, 15111,
						22307, 30815, 25901, 27415 }, // 16

				{ 1, 38401, 59817, 33763, 32385, 2887, 45473, 48221, 3193, 63355, 40783, 37741, 54515, 11741, 10889,
						17759, 6115, 18687, 19665, 26557 }, // 17

				{ 1, 100135, 28235, 46895, 82781, 36145, 36833, 130557, 73161, 2259, 3769, 2379, 80685, 127279, 45979,
						66891, 8969, 56169, 92713, 67743 }, // 18

				{ 1, 154805, 242105, 171449, 27859, 76855, 183825, 38785, 178577, 18925, 260553, 130473, 258343, 79593,
						96263, 36291, 2035, 198019, 15473, 148703 }, // 19

				{ 1, 387275, 314993, 50301, 174023, 354905, 303021, 486111, 286797, 463237, 211171, 216757, 29831,
						155061, 315509, 193933, 129563, 276501, 395079, 139111 } // 20
		};

		// 0.6^k
		int[] aMult = { 1, 103259, 511609, 482163, 299529, 491333, 30987, 286121, 388189, 39885, 413851, 523765, 501705,
				93009, 44163, 325229, 345483, 168873, 376109, 146111 };

		/*
		 * ******* MODEL
		 *********/

		// String outdir = "data/creditMetrics/KP5/";
		// String filename = "KP5.dat";
		// MonteCarloModelDouble model = new CreditMetrics(outdir + filename, noise);
		// int dim = ((CreditMetrics) model).getDimension();
		// double nomVal = ((CreditMetrics) model).nom();
		// ((CreditMetrics) model).normalize(nomVal);

//		MonteCarloModelDouble model = new San13("san13a.dat");
//		int dim = 13;

		double strike = 101.0;
		double s0 = 100.0;
		double sigma = 0.12136;
		double r = 0.1;
		int dim = 12;

		LookbackOptionGBM model = new LookbackOptionGBM(dim, s0, strike, r, sigma);

//		int dim = 11;
//		double[] sigmas = new double[dim];
////		Arrays.fill(sigmas,1.0);
//		
//		sigmas[0] = 1.0;
//		for(int j = 1; j<dim; j++)
//			sigmas[j] = sigmas[j-1] / Math.sqrt(2.0);
//
//		MonteCarloModelDouble model = new SumOfNormalsNormalized(sigmas);

		/*
		 * ************************ DENSITY ESTIMATOR
		 ****************************************/

		// double a = 98.5; //credit metrics
		// double b = 102.4;

//		double a = 22.0; // SAN
//		double b = 106.24;

		double a = strike;
		double b = strike + 34.4; // Lookback; cuts 0.08 left and 0.05 right --> 87% of mass

//		double a = -2.0;
//		double b = 2.0;

		int numEvalPts = 128; // numEvalPts =8;
		double[] evalPoints = genEvalPoints(numEvalPts, a, b, noise);
		// DEHistogram de = new DEHistogram(a, b, 32);
		DEKernelDensity de = new DEKernelDensity(new NormalDist());
		double[] hArray = { 0.353553, 0.5, 0.707107, 1., 1.41421, 2. };// lookback MC
		/*
		 * ************************ POINT SETS
		 ****************************************/
		// Create a list of series of RQMC point sets.
		ArrayList<RQMCPointSet[]> listRQMC = new ArrayList<RQMCPointSet[]>();
		PointSet p;
		PointSetRandomization rand;
		RQMCPointSet[] rqmcPts;

		// Independent points (Monte Carlo)
//		rqmcPts = new RQMCPointSet[numSets];
//		for (i = 0; i < numSets; ++i) {
//			p = new IndependentPointsCached(N[i], dim);
//			rand = new RandomShift(noise);
//			rqmcPts[i] = new RQMCPointSet(p, rand);
//		}
//		rqmcPts[0].setLabel("Independent points");
//		listRQMC.add(rqmcPts);

		// Stratification
//		 rqmcPts = new RQMCPointSet[numSets];
//		 int k;
//		 for (i = 0; i < numSets; ++i) {
//		 k = (int) Math.round(Math.pow(Num.TWOEXP[i + mink], 1.0 / (double) (dim)));
//		 p = new StratifiedUnitCube(k, dim);
//		
//		 rand = new RandomShift(noise);
//		 rqmcPts[i] = new RQMCPointSet(p, rand);
//		 }
//		 rqmcPts[0].setLabel("Stratification");
//		 listRQMC.add(rqmcPts);

		// lattice+shift
		rqmcPts = new RQMCPointSet[numSets];
		for (i = 0; i < numSets; ++i) {

//			p = new Rank1Lattice(N[i], aa[i], dim);
			p = new Rank1Lattice(N[i], aMult, dim);

			rand = new RandomShift(noise);
			rqmcPts[i] = new RQMCPointSet(p, rand);
		}
		rqmcPts[0].setLabel("Lattice+Shift");
		listRQMC.add(rqmcPts);

		// lattice+baker
		rqmcPts = new RQMCPointSet[numSets];
		for (i = 0; i < numSets; ++i) {

//		 p =  new BakerTransformedPointSet(new Rank1Lattice(N[i],aa[i],dim));
			p = new BakerTransformedPointSet(new Rank1Lattice(N[i], aMult, dim));

			rand = new RandomShift(noise);
			rqmcPts[i] = new RQMCPointSet(p, rand);
		}
		rqmcPts[0].setLabel("Lattice+Baker");
		listRQMC.add(rqmcPts);

//		// Sobol + LMS
//		rqmcPts = new RQMCPointSet[numSets];
//		for (i = 0; i < numSets; ++i) {
//
//			p = new SobolSequence(i + mink, 31, dim);
//
//			rand = new LMScrambleShift(noise);
//			rqmcPts[i] = new RQMCPointSet(p, rand);
//		}
//		rqmcPts[0].setLabel("Sobol+LMS");
//		listRQMC.add(rqmcPts);
//
//		// Sobol+NUS
//		rqmcPts = new RQMCPointSet[numSets];
//		for (i = 0; i < numSets; ++i) {
//			CachedPointSet cp = new CachedPointSet(new SobolSequence(N[i], dim));
//
//			cp.setRandomizeParent(false);
//			p = cp;
//
//			rand = new NestedUniformScrambling(noise, i + mink + 1);
//			rqmcPts[i] = new RQMCPointSet(p, rand);
//		}
//		rqmcPts[0].setLabel("Sobol+NUS");
//		listRQMC.add(rqmcPts);

		DEModelBandwidthBased modelbb = new DEModelBandwidthBased((DEKernelDensity) de, a, b);
		// DEModelBandwidthBased modelbb = new DEModelBandwidthBased(de, a, b);
		modelbb.setDisplayExec(true);
		modelbb.setProducePlots(true);

		// System.out.println(modelbb.testMISERate( model, rqmcPts, m,
		// (DEKernelDensity)de,
		// hArray, evalPoints, true));
		String output = modelbb.testMISERate(model, listRQMC, m, de, hArray, evalPoints);
		System.out.println(output);

		FileWriter fw = new FileWriter("output.txt");
		fw.write(output);
		fw.close();

	}

}
